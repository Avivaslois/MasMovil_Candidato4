# MasMovil CHALLENGE DotNet Core - Candidato4

## SOLUTION

My solution consits in two microservices deployed in single dockers (catalog and orders). 
This microservices are developed in .NET CORE 2.1. The catalog microservice implements an SQLite database, which is created with Entity Framework Code First pattern, if the local file "PhoneApp.db" doesn't exists.
Order microservice launches a request to recover the phone prices and log the final budget in console.

### Prerequisites
App Requirements:
	- Maven +3.3
	- Docker +17.12.0-ce
	- Docker Compose +1.17.0
	- Unix system
	- DotNet Core 2.1


### HOW TO RUN:

In "PhoneApp" directory, launch command 

```
docker-compose up
```

*Example of use documented in "Example.docx"

This command will setup two containers in this IP's: 127.0.0.1:8080 (Catalog MicroService) and 127.0.0.1:8081 (Order MicroService)

### Questions

¿How would you improve your system?


•	Inclusion of a new microservice or gateway to orchestrate and coordinate calls between different microservices, in this case those corresponding to the catalog (Catalog API) and orders (Order API).
Mostly, client applications need to use different microservices to complete operations. In this example, you need to query catalog information (Catalog API) to complete an order (Order API). Without making use of additional components, the proposed architecture forces a microservice (Order API) to know the location or endpoint of the other (Catalog API). This is not optimal in terms of maintainability or scalability, and it is not completely aligned with the architecture model based on microservices.
The first improvement would lie in the incorporation of a new microservice or gateway, as the only element of initial interaction with the client application. Thus, the client application will only know the location of the gateway and each microservice will be loosely coupled to the rest by means of this component, without interaction or direct calls between them. The gateway will be the component responsible for making, orchestrating and coordinating calls between microservices.
For example, to complete an order the gateway will be in charge of calling the microservice that manages the catalog (Catalog API), extracting results and using them to make another call to the order microservice (Order API). Finally, you must validate the operation using the information received by both microservices.
In addition, in order to improve the performance of the application, in case of implementing more complex tasks or incorporating new microservices (for example, Client API to query client data or Cache API to provide cache services) you should be able to:
o	Aggregate results from multiple calls into a single one that will be returned to the client application.
o	Parallelize asynchronous calls to different microservices.
o	Balance calls on replicated microservices after evaluating the load to which they are dealing with, selecting the one with the least activity. 
Further improvements in this context would include the configuration of several gateways to improve the resilience of our application, the configuration of each of the gateways to make calls to different microservices according to the type of client application or the inclusion of security to authorize client applications.
•	Add logging services. A good option would be to add a new microservice to register all the logging activity generated by the application, for example, by means of a new Log API. This new microservice could be called directly by the gateway or even by the rest of microservices using asynchronous calls. 

•	Implement cache services, either at individual microservice level (each microservice stores its own cache data) or at a general level, (each microservice makes use of a shared distributed cache memory service, for example, Alachisoft NCache).

•	Separation of database in multiple databases, each one specific to the tasks developed by each microservice. This allows decoupling and improving the independence between microservices. 

•	Add advanced communication services between microservices in operations that require data consistency and transactional operations, especially important in case of using different databases between microservices. The solutions or improvements in this regard would involve the inclusion of components to provide support for communication between microservices, for example, via events. Each operation performed by a microservice is capable of generating the publication of an event to which one or more microservices that are listening can be subscribed. 

 
¿How would you avoid your order API to be overflow?
•	Replication of the Order API microservice to balance calls according to the load, all of them coordinated and orchestrated by a Gateway-type microservice.

•	The gateway microservice will be in charge of evaluating the network status to balance the call requests to the Order API, selecting the instance with the lowest load. 

•	In case of implementing cache services, make use of them to getting information required to compete the order. For example, customer-specific data or phone catalog data that is not usually modified could be stored in a cache component in the corresponding microservices or in a new microservice (Cache API) over a distributed cache memory. This would decrease the activity on the databases, while improving the performance when operating with the Order API.

•	At database level, keep transaction levels at the lowest isolation level needed to avoid blocks in high-concurrent environments. Make transactions as short as possible and get out of them any kind of query that can be done outside.



